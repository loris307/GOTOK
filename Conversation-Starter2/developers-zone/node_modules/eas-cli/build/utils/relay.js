"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPaginatedDatasetAsync = void 0;
/**
 * Fetches dataset in paginated manner (batch by batch) using GraphQL queries.
 *
 * @param queryAsync A promise based function for querying.
 * @param beforeEachQuery Optional. A callback function to be called before each query
 * @param afterEachQuery Optional. A callback function to be called after each query.
 * @param filterPredicate Optional. A predicate function to filter the node.
 * @param batchSize Optional. The batch size of the pagination. Defaults to 100.
 *
 * @return {Promise<T[]>} - A promise that resolves to an array (the dataset).
 * @throws {Error} - If an error occurs during execution of the query or pagination.
 */
async function getPaginatedDatasetAsync({ queryAsync, beforeEachQuery, afterEachQuery, filterPredicate, batchSize = 100, maxNodesFetched = 10000, }) {
    var _a;
    const dataset = [];
    let hasMore = true;
    let after;
    let totalNodesFetched = 0;
    while (hasMore) {
        if (beforeEachQuery) {
            beforeEachQuery(totalNodesFetched, dataset);
        }
        const result = await queryAsync({ first: batchSize, after });
        const { edges, pageInfo } = result;
        const nodes = edges.map(edge => edge.node);
        const batch = filterPredicate ? nodes.filter(filterPredicate) : nodes;
        dataset.push(...batch);
        hasMore = pageInfo.hasNextPage;
        after = (_a = pageInfo.endCursor) !== null && _a !== void 0 ? _a : undefined;
        totalNodesFetched += nodes.length;
        if (afterEachQuery) {
            afterEachQuery(totalNodesFetched, dataset, batch, pageInfo);
        }
        if (totalNodesFetched >= maxNodesFetched) {
            return dataset;
        }
    }
    return dataset;
}
exports.getPaginatedDatasetAsync = getPaginatedDatasetAsync;
