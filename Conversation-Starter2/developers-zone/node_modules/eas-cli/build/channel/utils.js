"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpdateBranch = exports.logChannelDetails = exports.getBranchMapping = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_1 = tslib_1.__importDefault(require("../log"));
const utils_1 = require("../update/utils");
const branch_mapping_1 = require("./branch-mapping");
/**
 * Get the branch mapping and determine whether it is a rollout.
 * Ensure that the branch mapping is properly formatted.
 */
function getBranchMapping(branchMappingString) {
    var _a;
    if (!branchMappingString) {
        throw new Error('Missing branch mapping.');
    }
    let branchMapping;
    try {
        branchMapping = JSON.parse(branchMappingString);
    }
    catch {
        throw new Error(`Could not parse branchMapping string into a JSON: "${branchMappingString}"`);
    }
    (0, assert_1.default)(branchMapping, 'Branch Mapping must be defined.');
    if (branchMapping.version !== 0) {
        throw new Error('Branch mapping must be version 0.');
    }
    const isRollout = branchMapping.data.length === 2;
    const branchMappingNode = (_a = branchMapping.data[0]) === null || _a === void 0 ? void 0 : _a.branchMappingLogic;
    let rolloutPercent;
    if ((0, branch_mapping_1.isNodeObject)(branchMappingNode)) {
        (0, branch_mapping_1.assertNumber)(branchMappingNode.operand);
        rolloutPercent = branchMappingNode.operand;
    }
    switch (branchMapping.data.length) {
        case 0:
            break;
        case 1:
            if (branchMapping.data[0].branchMappingLogic !== 'true') {
                throw new Error('Branch mapping logic for a single branch must be "true"');
            }
            break;
        case 2:
            (0, branch_mapping_1.assertNodeObject)(branchMappingNode);
            if (branchMappingNode.clientKey !== 'rolloutToken') {
                throw new Error('Client key of initial branch mapping must be "rolloutToken"');
            }
            if (branchMappingNode.branchMappingOperator !== 'hash_lt') {
                throw new Error('Branch mapping operator of initial branch mapping must be "hash_lt"');
            }
            if (rolloutPercent == null) {
                throw new Error('Branch mapping is missing a "rolloutPercent"');
            }
            if (branchMapping.data[1].branchMappingLogic !== 'true') {
                throw new Error('Branch mapping logic for a the second branch of a rollout must be "true"');
            }
            break;
        default:
            throw new Error('Branch mapping data must have length less than or equal to 2.');
    }
    return { branchMapping, isRollout, rolloutPercent };
}
exports.getBranchMapping = getBranchMapping;
function logChannelDetails(channel) {
    const { branchMapping, isRollout, rolloutPercent } = getBranchMapping(channel.branchMapping);
    if (branchMapping.data.length > 2) {
        throw new Error('Branch Mapping data must have length less than or equal to 2.');
    }
    const rolloutBranchIds = branchMapping.data.map(data => data.branchId);
    const branchDescription = channel.updateBranches.flatMap(branch => {
        const updateGroupWithBranchDescriptions = (0, utils_1.getUpdateGroupDescriptionsWithBranch)(branch.updateGroups);
        const isRolloutBranch = isRollout && rolloutBranchIds.includes(branch.id);
        const isBaseBranch = rolloutBranchIds.length > 0 && rolloutBranchIds[0] === branch.id;
        let rolloutPercentNumber = undefined;
        if (isRolloutBranch) {
            rolloutPercentNumber = isBaseBranch ? rolloutPercent * 100 : (1 - rolloutPercent) * 100;
        }
        return updateGroupWithBranchDescriptions.map(({ branch, ...updateGroup }) => ({
            branch,
            branchRolloutPercentage: rolloutPercentNumber,
            update: updateGroup,
        }));
    });
    if (branchDescription.length === 0) {
        log_1.default.log(chalk_1.default.dim('No branches are pointed to this channel.'));
    }
    else {
        log_1.default.log(branchDescription
            .map(description => (0, utils_1.formatBranch)(description))
            .join(`\n\n${chalk_1.default.dim('———')}\n\n`));
    }
}
exports.logChannelDetails = logChannelDetails;
function getUpdateBranchNullable(channel, branchId) {
    const updateBranches = channel.updateBranches;
    const updateBranch = updateBranches.find(branch => branch.id === branchId);
    return updateBranch !== null && updateBranch !== void 0 ? updateBranch : null;
}
function getUpdateBranch(channel, branchId) {
    const updateBranch = getUpdateBranchNullable(channel, branchId);
    if (!updateBranch) {
        throw new Error(`Could not find branch with id "${branchId}" in branch-mapping of channel "${channel.name}"`);
    }
    return updateBranch;
}
exports.getUpdateBranch = getUpdateBranch;
